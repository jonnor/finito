# Finito - Finite State Machines 
# Copyright (c) 2014 Jon Nordby <jononor@gmail.com>
# Finito may be freely distributed under the MIT license
##

# TODO: allow to calculate all impossible paths, for a given state and whole machine

# TODO: allow machine definition together with states
# FIXME: support a context object

pkginfo = (require 'pkginfo')(module)

events = require 'events'

class Machine extends events.EventEmitter

    constructor: (def, code) ->
        @def = def
        @state = def.initial.state
        @code = code

    run: () =>
        @execute @state

        for transition in @def.transitions
            if @state == transition.from and @execute transition.when
                @changeState transition.to
                break

    execute: (name) =>
        return @code[name]()

    changeState: (newState) =>
        # TODO: support enter/leave states
        @emit 'statechange', @state, newState
        @state = newState


normalizeMachineDefinition = (def) ->
    id = 0
    for name, state of def.states
        def.states[name].id = id++
        def.states[name].enum = def.name+'_'+name

# IDEA: split C codegen out into common library, share with MicroFlo?
generateEnum = (name, prefix, enums) ->
    if Object.keys(enums).length == 0
        return ""
    indent = "\n    "

    out = "enum " + name + " {";
    a = []
    for e, val of enums
        v = if (val.id != undefined) then " = " + val.id else ""
        a.push (indent + prefix + e + v)
    out += a.join ","
    out += "\n};\n"

    return out

nameToEnum = (name, values) ->
    return values[name].enum

nameToId = (name, values) ->
    return values[name].id

idToName = (id, values) ->
    for name, val of values
        if val.id == id
            return name

# IDEA: add a C machine definition based on function pointers that does not require any code generation

generateRunFunction = (name, def) ->
    indent = "    "
    r = "FinitoStateId " + name + "(FinitoStateId current_state) {\n"

    r += indent + "// Running state \n"
    r += indent + "switch (current_state) {\n"
    for state, val of def.states
        stateId = nameToEnum state, def.states
        r+= indent + "case #{stateId}: #{state}(); break; \n"
    r += indent + "}\n"

    r += indent + "\n"

    r += indent + "// Checking transition predicates \n"
    for transition in def.transitions
        fromId = nameToEnum transition.from, def.states
        toId = nameToEnum transition.to, def.states
        r += indent+"if (current_state == #{fromId} && #{transition.when}() ) return #{toId};\n"

    r += indent + "return current_state;\n"
    r += "}\n"
    return r

generateInitial = (name, def) ->
    return 'const FinitoStateId ' + name + " = " + nameToId(def.initial.state, def.states) + ";\n"

generateStringMap = (mapname, values) ->
    indent = "    "
    r = "static const char *#{mapname}[] = {\n"
    for name, val of values
        r += indent+"\"#{name}\",\n"
    r.trim ","

    r+= "};\n"
    return r

generateDefinition = (name, def) ->
    indent = "   "
    r = "FinitoDefinition #{name}_def = {\n"
    initial = nameToId(def.initial.state, def.states)
    r += indent+"#{initial}, #{name}_run, #{name}_statenames\n"
    r += "};\n"
    return r

# TODO: generate id -> char * map for transitions
generateCMachine = (def) ->
    name = def.name
    g = "// Generated by Finito State Machine\n"
    g += generateEnum name+'States', name+'_', def.states
    g += generateStringMap name+'_statenames', def.states
    g += generateRunFunction name+'_run', def
    g += generateDefinition name, def
    return g

exports.Machine = Machine
exports.main = () ->

    commander = require 'commander'
    fs = require 'fs'
    path = require 'path'

    commander
        .version module.exports.version

    commander
        .command 'generate'
        .option '-o, --output <FILE>', 'Output file'
        .description 'Generate (only needed for some target languages like C)'
        .action (infile, env) ->
            outfile = env.output || path.basename infile + '-gen.c'

            d = JSON.parse fs.readFileSync infile
            normalizeMachineDefinition d
            fs.writeFileSync outfile, generateCMachine d

    commander.parse process.argv
