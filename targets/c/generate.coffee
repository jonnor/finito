
nameToEnum = (name, values) ->
    return values[name]?.enum

nameToId = (name, values) ->
    return values[name]?.id

idToName = (id, values) ->
    for name, val of values
        if val.id == id
            return name

# TODO: use declarec instead of custom code generation for declarations
generateEnum = (name, prefix, enums) ->
    if Object.keys(enums).length == 0
        return ""
    indent = "\n    "

    out = "enum " + name + " {";
    a = []
    for e, val of enums
        v = if (val.id != undefined) then " = " + val.id else ""
        a.push (indent + prefix + e + v)
    out += a.join ","
    out += "\n};\n"

    return out

normalizeCArgs = (args, def, readwrite) ->
    ref = if readwrite then "" else "const "
    ctx = "(#{ref}#{def.context} *)(context)"
    newargs = [ctx]
    for a in args
        if a?
            newargs.push a

    return newargs.join ','

# IDEA: add a C machine definition based on function pointers that does not require any code generation
# TODO: support callbacks in addition to polling transition functions
generateTransitionFunction = (name, def) ->
    indent = "    "
    r = "FinitoStateId " + name + "(FinitoStateId current_state, void *context) {\n"

    r += indent + "// Running state \n"
    r += indent + "switch (current_state) {\n"
    for name, state of def.states
        stateId = nameToEnum name, def.states
        r+= indent + "case #{stateId}: \n"

        # Transition predicate
        for transition in state.transitions
            fromId = nameToEnum transition.from, def.states
            toId = nameToEnum transition.to, def.states
            func = transition.when.function
            args = normalizeCArgs transition.when.args, def
            predicate = if func == "true" or func == "false" then func else "#{func}(#{args})"
            r += indent+indent+"if (#{predicate}) { return #{toId}; } \n"

        r += indent+indent+"break;\n"

    r += indent+"default: break;\n"
    r += indent + "}\n"
    r += indent + "\n"

    r += indent + "return current_state;\n"
    r += "}\n"

generateStateChangeFunction = (name, def) ->
    indent = "    "
    r = "void " + name + "(FinitoStateId current_state, FinitoStateId new_state, void *context) {\n"
    r += indent+"if (new_state == current_state) { return;  }\n\n"

    r += indent + "// Leave\n"
    r += indent + "switch (current_state) {\n"
    for name, state of def.states
        stateId = nameToEnum name, def.states
        fun = state.leave.function
        if fun
            args = normalizeCArgs state.leave.args, def, true
            predicate = if fun == "true" or fun == "false" then fun else "#{fun}(#{args})"
            r+= indent+indent+"case #{stateId}: #{predicate}; break;\n"
    r += indent+indent+"default: break;\n"
    r += indent + "}\n"

    r += indent + "// Enter\n"
    r += indent + "switch (new_state) {\n"
    for name, state of def.states
        stateId = nameToEnum name, def.states
        fun = state.enter.function
        if fun
            args = normalizeCArgs state.enter.args, def, true
            r+= indent+indent+"case #{stateId}: #{fun}(#{args}); break; \n"
    r += indent+indent+"default: break;\n"

    r += indent + "}\n"

    # TODO: only run if no state transition?
    r += indent + "// Run\n"
    r += indent + "switch (new_state) {\n"
    for name, state of def.states
        stateId = nameToEnum name, def.states
        fun = state.run.function
        if fun
            args = normalizeCArgs state.run.args, def, true
            r+= indent+indent+"case #{stateId}: #{func}(#{args}); break; \n"
    r += indent+indent+"default: break;\n"
    r += indent + "}\n"

    r += indent + "return;\n"
    r += "}\n"
    return r

generateStringMap = (mapname, values) ->
    indent = "    "
    r = "static const char *#{mapname}[] = {\n"
    for name, val of values
        r += indent+"\"#{name}\",\n"
    r.trim ","

    r+= "};\n"
    return r

generateDefinition = (name, def) ->
    indent = "   "
    r = "FinitoDefinition #{name}_def = {\n"
    initial = nameToId(def.initial.state, def.states)
    exit = nameToId(def.exit.state, def.states) or -1
    r += indent+"#{initial}, #{exit}, #{name}_nextstate, #{name}_changestate, #{name}_statenames\n"
    r += "};\n"
    return r

# TODO: generate id -> char * map for transitions
generateCMachine = (def) ->
    name = def.name
    g = "// Generated by Finito State Machine\n"
    g += generateEnum name+'States', name+'_', def.states
    g += generateStringMap name+'_statenames', def.states
    g += generateTransitionFunction name+'_nextstate', def
    g += generateStateChangeFunction name+'_changestate', def
    g += generateDefinition name, def
    return g

module.exports = generateCMachine
