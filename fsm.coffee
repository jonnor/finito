
# TODO: allow to calculate all impossible paths, for a given state and whole machine

# TODO: allow machine definition together with states
# FIXME: support a context object

events = require 'events'

class StateMachine extends events.EventEmitter

    constructor: (def, code) ->
        @def = def
        @state = def.initial.state
        @code = code

    run: () =>
        @execute @state

        for transition in @def.transitions
            if @state == transition.from and @execute transition.when
                @changeState transition.to
                break

    execute: (name) =>
        return @code[name]()

    changeState: (newState) =>
        # TODO: support enter/leave states
        @emit 'statechange', @state, newState
        @state = newState


normalizeMachineDefinition = (def) ->
    id = 0
    for name, state of def.states
        def.states[name].id = id++
        def.states[name].enum = def.name+'_'+name

# FIXME: split out into common library
generateEnum = (require '../microflo/lib/generate.js').generateEnum

nameToEnum = (name, values) ->
    return values[name].enum

nameToId = (name, values) ->
    return values[name].id

idToName = (id, values) ->
    for name, val of values
        if val.id == id
            return name

# IDEA: add a C machine definition based on function pointers that does not require any code generation

generateRunFunction = (name, def) ->
    indent = "    "
    r = "FsmStateId " + name + "(FsmStateId current_state) {\n"

    r += indent + "// Running state \n"
    r += indent + "switch (current_state) {\n"
    for state, val of def.states
        stateId = nameToEnum state, def.states
        r+= indent + "case #{stateId}: #{state}(); break; \n"
    r += indent + "}\n"

    r += indent + "\n"

    r += indent + "// Checking transition predicates \n"
    for transition in def.transitions
        fromId = nameToEnum transition.from, def.states
        toId = nameToEnum transition.to, def.states
        r += indent+"if (current_state == #{fromId} && #{transition.when}() ) return #{toId};\n"

    r += indent + "return current_state;\n"
    r += "}\n"
    return r

generateInitial = (name, def) ->
    return 'const FsmStateId ' + name + " = " + nameToId(def.initial.state, def.states) + ";\n"

# FIXME: generate id -> char * maps for states
# TODO: generate id -> char * map for transitions
generateCMachine = (def) ->
    name = def.name
    g = "// Generated by Finito State Machine\n"
    g += generateEnum name+'States', name+'_', d.states
    g += generateInitial name+'_initial', d
    g += generateRunFunction name+'_run', d
    return g

d = require "./examples/first/machine.json"
normalizeMachineDefinition d

exports.main = () ->
    c = require "./examples/first/states.coffee"
    m = new StateMachine d, c

    m.on 'statechange', (n, old) ->
        console.log 'statechange', n, old

    m.run()
    m.run()
    m.run()

# exports.main()

fs = require 'fs'
fs.writeFileSync "mymachine-gen.c", generateCMachine d
